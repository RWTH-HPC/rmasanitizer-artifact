\documentclass[twoside]{article}
\usepackage{url}

\begin{document}

In the following, we document the steps to reproduce the results on classification quality and the overhead study.
For the classification quality experiment, we expect to set up and run everything within 60 to 90 minutes.
For the overhead study, in case of all software requirements are installed, the execution of the overhead study requires running a few JUBE commands and finally parsing the output to a Python script. While running all the commands will only take a few minutes, the execution of the jobs using Slurm will take a few hours.

\subsection*{Classification Quality}
To reproduce the classification quality results, an installation of Docker or Podman is required.

The following steps can \textit{all} be automatically executed by running the script \texttt{classification\_quality.sh} of the computational artifact.
Create the Docker container of RMARaceBench using the Dockerfile in this repository, run the container. Within the container, run the test harness of RMARaceBench.
{
\small
\begin{verbatim}
# cd classification_quality/rmaracebench
# docker build . -t rmaracebench
# docker run -it rmaracebench
# python run_test.py tools --rma-model MPIRMA --tool 'MUST-RMA' 'PARCOACH-dynamic' 'PARCOACH-static'`
# python run_test.py tools --rma-model MPIRMA --tool 'RMASanitizer'
# python run_test.py tools --rma-model SHMEM --tool 'RMASanitizer'
# python run_test.py tools --rma-model GASPI --tool 'RMASanitizer'
\end{verbatim}
}

After following these steps, the results generated should match those given in the computational artifact and represent the Table 3 in the paper.

Note: In very recent Linux kernel versions newer than 6.0, the address space layout randomization (ASLR) bit count must be below or equal 28. This can be done temporarily (until system reboot) on typical Linux systemd-based systems using \texttt{sysctl vm.mmap\_rnd\_bits=28}. This command needs root permissions. This is a requirement of the ThreadSanitizer version shipped MUST-RMA and RMASanitizer.


\section*{Overhead Study}
The overhead study was performed in JUBE. The previously mentioned software (OpenMPI, Sandia SHMEM, GPI-2, Clang/Classic-Flang) has to be installed to be executed.

To run the benchmarks, we used a JUBE workflow that builds RMASanitizer and MUST-RMA, builds the source codes, submits the jobs via Slurm, and finally evaluates the results to generate output tables.
For MUST-RMA, the benchmarks executed are \texttt{PRK\_stencil}, \texttt{BT-RMA}, \texttt{lulesh}, \texttt{miniMD}.
For RMASanitizer, the benchmarks executed are \texttt{PRK\_stencil}, \texttt{BT-RMA},  \texttt{lulesh}, \texttt{miniMD} \texttt{PRK\_stencil\_shmem}, \texttt{BT-SHMEM}, \texttt{CFD-Proxy}.
For each benchmark \texttt{benchname} with MUST-RMA or RMASanitizer, we executed the following to build and submit the benchmark:

{
\small
\begin{verbatim}
# Run benchmark with MUST-RMA
# jube run <benchmark>.xml -o MUST-RMA/<benchmark> \
  --tag M ignorelist pnmpi memusage rebuild_source must-rma
# Run benchmark with RMASanitizer
# jube run <benchmark>.xml -o RMASanitizer/<benchmark> \
  --tag M ignorelist pnmpi memusage rebuild_source
\end{verbatim}
}

After all jobs completed, the results can be retrieved via JUBE that parses the outputs of all jobs:

{
\small
\begin{verbatim}
# Parse result of benchmark with MUST-RMA
# jube result MUST-RMA/<benchmark>/000000
# Parse result of benchmark with RMASanitizer
# jube result RMASanitizer/<benchmark>/000000
\end{verbatim}
}

Finally, the results can be plotted with the plotting script that parses all the output tables of JUBE:
{
\small
\begin{verbatim}
# python evaluation_results/plots/plot_performance_results.py
\end{verbatim}
}

This will generate exactly the plots of Figure 9 in the paper. The paper also makes statements about them memory usage and the number of RMA operations executed per second. This data is also included in the result tables generated by JUBE.

For simplicity, all those steps are available in a script \texttt{overhead\_submit.sh} and \texttt{overhead\_results.sh} that can be executed to generate the results and the plot.

\end{document}